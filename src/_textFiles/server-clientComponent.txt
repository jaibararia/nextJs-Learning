
- By default, layouts and pages are Server Components, which lets you fetch data and render parts of your UI on the server, optionally cache the result, and stream it to the client.
- When you need interactivity or browser APIs, you can use Client Components to layer in functionality.

=> When to use Server and Client Components?
- Use Client Components when you need:
    - State and event handlers. E.g. onClick, onChange.
    - Lifecycle logic. E.g. useEffect.
    - Browser-only APIs. E.g. localStorage, window, Navigator.geolocation, etc.
    - Custom Hooks.

- Use Server Components when you need:
    - Fetch data from databases or APIs close to the source.
    - Use API keys, tokens, and other secrets without exposing them to the client.
    - Reduce the amount of JavaScript sent to the browser.
    - Improve the First Contentful Paint (FCP), and stream content progressively to the client.

=> How do Server and Client Components work in Next.js?

-> On the Server
- On the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks, by individual route segments (layouts and pages):
    - Server Components are rendered into a special data format called the React Server Component Payload (RSC Payload).
    - Client Components and the RSC Payload are used to prerender HTML.

-> What is the React Server Component Payload (RSC)?
- The RSC Payload is a compact binary representation of the rendered React Server Components tree. 
- It's used by React on the client to update the browser's DOM. The RSC Payload contains:
    - The rendered result of Server Components
    - Placeholders for where Client Components should be rendered and references to their JavaScript files
    - Any props passed from a Server Component to a Client Component

-> On the client (first load)

- Then, on the client:

    - HTML is used to immediately show a fast non-interactive preview of the route to the user.
    - RSC Payload is used to reconcile the Client and Server Component trees.
    - JavaScript is used to hydrate Client Components and make the application interactive.

- What is hydration?
    - Hydration is React's process for attaching event handlers to the DOM, to make the static HTML interactive.

-> Subsequent Navigations
 On subsequent navigations:

- The RSC Payload is prefetched and cached for instant navigation.
- Client Components are rendered entirely on the client, without the server-rendered HTML.

Examples

-> Using Client Component

- You can create a Client Component by adding the "use client" directive at the top of the file, above your imports.
- "use client" is used to declare a boundary between the Server and Client module graphs (trees).
- Once a file is marked with "use client", all its imports and child components are considered part of the client bundle.
- This means you don't need to add the directive to every component that is intended for the client.

- Check the app/component/counter.tsx file

-> Reducing JS bundle size
- To reduce the size of your client JavaScript bundles, add 'use client' to specific interactive components instead of marking large parts of your UI as Client Components.
- For example, the <Layout> component contains mostly static elements like a logo and navigation links, but includes an interactive search bar.
- <Search /> is interactive and needs to be a Client Component, however, the rest of the layout can remain a Server Component.

Example

==== code =====
- app/layout.tsx

// Client Component
import Search from './search'
// Server Component
import Logo from './logo'
 
// Layout is a Server Component by default
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Logo />
        <Search />
      </nav>
      <main>{children}</main>
    </>
  )
}

- app/component/search.tsx

'use client'
 
export default function Search() {
  // ...
}

-> Passing data from Server to Client Components

- You can pass data from Server Components to Client Components using props.
- Alternatively, you can stream data from a Server Component to a Client Component with the use Hook. 
- Good to know: Props passed to Client Components need to be serializable by React.

example
app/[slug]/page.tsx

export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>
})

-> Interleaving Server and Client Components

- You can pass Server Components as a prop to a Client Component.
- This allows you to visually nest server-rendered UI within Client components.
- A common pattern is to use children to create a slot in a <ClientComponent>. 
- For example, a <Cart> component that fetches data on the server, inside a <Modal> component that uses client state to toggle visibility.

Example:
- app/component/modal.tsx

'use client'
 
export default function Modal({ children }: { children: React.ReactNode }) {
  return <div>{children}</div>
}

- Then, in a parent Server Component (e.g.<Page>), you can pass a <Cart> as the child of the <Modal>:

- app/page.tsx
import Modal from './ui/modal'
import Cart from './ui/cart'
 
export default function Page() {
  return (
    <Modal>
      <Cart />
    </Modal>
  )
}

- In this pattern, all Server Components will be rendered on the server ahead of time, including those as props.
- The resulting RSC payload will contain references of where Client Components should be rendered within the component tree.

-> Context Providers

- React context is commonly used to share global state like the current theme.
- However, React context is not supported in Server Components.
- To use context, create a Client Component that accepts children:

Example
- app/theme-provider.tsx

'use client'
 
import { createContext } from 'react'
 
export const ThemeContext = createContext({})
 
export default function ThemeProvider({
  children,
}: {
  children: React.ReactNode
}) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}

- Then, import it into a Server Component (e.g. layout):

- app/layout.tsx

import ThemeProvider from './theme-provider'
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}

- Good to know: You should render providers as deep as possible in the tree – notice how ThemeProvider only wraps {children} instead of the entire <html> document.
- This makes it easier for Next.js to optimize the static parts of your Server Components.

=> Third-party components
- When using a third-party component that relies on client-only features, you can wrap it in a Client Component to ensure it works as expected.
- For example, the <Carousel /> can be imported from the acme-carousel package.
- This component uses useState, but it doesn't yet have the "use client" directive.

- If you use <Carousel /> within a Client Component, it will work as expected:

===== code =====
- app/gallery.tsx

'use client'
 
import { useState } from 'react'
import { Carousel } from 'acme-carousel'
 
export default function Gallery() {
  const [isOpen, setIsOpen] = useState(false)
 
  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>
      {/* Works, since Carousel is used within a Client Component */}
      {isOpen && <Carousel />}
    </div>
  )
}
===========================

- However, if you try to use it directly within a Server Component, you'll see an error.
- This is because Next.js doesn't know <Carousel /> is using client-only features.
- To fix this, you can wrap third-party components that rely on client-only features in your own Client Components:

===== code =====
- app/carousel.tsx

'use client'
 
import { Carousel } from 'acme-carousel'
 
export default Carousel

=====================

===== code =======
- app/page.tsx

import Carousel from './carousel'
 
export default function Page() {
  return (
    <div>
      <p>View pictures</p>
      {/*  Works, since Carousel is a Client Component */}
      <Carousel />
    </div>
  )
}

    -> Advice for Library Authors
        - If you’re building a component library, add the "use client" directive to entry points that rely on client-only features.
        - This lets your users import components into Server Components without needing to create wrappers.

=> Preventing environment poisoning
- JavaScript modules can be shared between both Server and Client Components modules.
- This means it's possible to accidentally import server-only code into the client.

- Use the server-only package into your project once installed then whenever you add server-only code into the component then add this code at top
"import 'server-only'"
- Now, if you try to import the module into a Client Component, there will be a build-time error.

- To install server only package use this cmd - "npm install server-only"
