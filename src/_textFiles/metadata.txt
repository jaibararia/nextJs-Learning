Metadata and OG Images

- The Metadata APIs can be used to define your application metadata for improved SEO and web shareability and include:
    - The static metadata object
    - The dynamic generateMetadata function
    - Special file conventions that can be used to add static or dynamically generated favicons and OG images.

- The metadata object and generateMetadata function exports are only supported in Server Components.


-> Default fields
- There are two default meta tags that are always added even if a route doesn't define metadata:

    - The meta charset tag sets the character encoding for the website.
    - The meta viewport tag sets the viewport width and scale for the website to adjust for different devices.

example:
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

- The other metadata fields can be defined with the Metadata object (for static metadata) or the generateMetadata function (for generated metadata).

-> Static metadata

- To define static metadata, export a Metadata object from a static layout.js or page.js file.

- example => app/blog/layout.tsx

import type { Metadata } from 'next'
 
export const metadata: Metadata = {
  title: 'My Blog',
  description: '...',
}
 
export default function Page() {}

-> Generated metadata
- You can use generateMetadata function to fetch metadata that depends on data.

example: app/blog/[slug]/page.tsx

import type { Metadata, ResolvingMetadata } from 'next'
 
type Props = {
  params: Promise<{ slug: string }>
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}
 
export async function generateMetadata(
  { params, searchParams }: Props,
  parent: ResolvingMetadata
): Promise<Metadata> {
  const slug = (await params).slug
 
  // fetch post information
  const post = await fetch(`https://api.vercel.app/blog/${slug}`).then((res) =>
    res.json()
  )
 
  return {
    title: post.title,
    description: post.description,
  }
}
 
export default function Page({ params, searchParams }: Props) {}

-> Streaming metadata

- For dynamically rendered pages, if resolving generateMetadata might block rendering, Next.js streams the resolved metadata separately and injects it into the HTML as soon as it's ready.
- Statically rendered pages donâ€™t use this behavior since metadata is resolved at build time.

-> Memoizing data requests
- There may be cases where you need to fetch the same data for metadata and the page itself. 
- To avoid duplicate requests, you can use React's cache function to memoize the return value and only fetch the data once. 
- For example, to fetch the blog post information for both the metadata and the page:

- app/lib/data.ts

import { cache } from 'react'
import { db } from '@/app/lib/db'
 
// getPost will be used twice, but execute only once
export const getPost = cache(async (slug: string) => {
  const res = await db.query.posts.findFirst({ where: eq(posts.slug, slug) })
  return res
})

- app/blog/[slug]/page.tsx

import { getPost } from '@/app/lib/data'
 
export async function generateMetadata({
  params,
}: {
  params: { slug: string }
}) {
  const post = await getPost(params.slug)
  return {
    title: post.title,
    description: post.description,
  }
}
 
export default async function Page({ params }: { params: { slug: string } }) {
  const post = await getPost(params.slug)
  return <div>{post.title}</div>
}

-> Generated Open Graph images

- The ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for OG images that depend on data.
- For example, to generate a unique OG image for each blog post, add a opengraph-image.tsx file inside the blog folder, and import the ImageResponse constructor from next/og:

- app/blog/[slug]/opengraph-image.tsx

import { ImageResponse } from 'next/og'
import { getPost } from '@/app/lib/data'
 
// Image metadata
export const size = {
  width: 1200,
  height: 630,
}
 
export const contentType = 'image/png'
 
// Image generation
export default async function Image({ params }: { params: { slug: string } }) {
  const post = await getPost(params.slug)
 
  return new ImageResponse(
    (
      // ImageResponse JSX element
      <div
        style={{
          fontSize: 128,
          background: 'white',
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
        }}
      >
        {post.title}
      </div>
    )
  )
}

- ImageResponse supports common CSS properties including flexbox and absolute positioning, custom fonts, text wrapping, centering, and nested images.