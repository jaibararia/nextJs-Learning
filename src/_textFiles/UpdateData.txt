=> Updating Data

- You can update data in Next.js using React's Server Functions.
- This page will go through how you can create and invoke Server Functions.

-> Creating Server Functions
- A Server Function can be defined by using the "use server" directive.
- You can place the directive at the top of an asynchronous function to mark the function as a Server Function, or at the top of a separate file to mark all exports of that file.

Example: 

export async function createPost(formData: FormData){
    'use server'
    const title = formData.get('title');
    const content = formData.get('content');

    //update data
    // Revalidate Cache
}

export async function deletePost(formData: FormData) {
    'use server'
    const id = formData.get('id')

    // Update Data
    // Revalidate Cache
}

-> Server Components
- Server Functions can be inlined in Server Components by adding the "use server" directive to the top of the function body:

Example:

export default function Page(){
    // Server Action 
    async function createPost(formData: FormData){
        'use server'
        // ...
    }

    return <></>
}

Good to know: 
- Server Components support progressive enhancement by default, meaning forms that call Server Actions will be submitted even if JavaScript hasn't loaded yet or is disabled.

-> Client Components
- It's not possible to define Server Functions in Client Components.
- However, you can invoke them in Client Components by importing them from a file that has the "use server" directive at the top of it:

Example:
- app/actions.ts

'use server'
 
export async function createPost() {}

- app/ui/button.tsx

'use client'
 
import { createPost } from '@/app/actions'
 
export function Button() {
  return <button formAction={createPost}>Create</button>
}

- Good to know:
    - In Client Components, forms invoking Server Actions will queue submissions if JavaScript isn't loaded yet, and will be prioritized for hydration.
    - After hydration, the browser does not refresh on form submission.

-> Passing actions as props
- You can also pass an action to a Client Component as a prop:
Example 
- <ClientComponent updateItemAction={updateItem} />

- app/client-component.tsx
'use client'
 
export default function ClientComponent({
  updateItemAction,
}: {
  updateItemAction: (formData: FormData) => void
}) {
  return <form action={updateItemAction}>{/* ... */}</form>
}

-> Invoking Server Functions

There are two main ways you can invoke a Server Function:

- Forms in Server and Client Components
- Event Handlers and useEffect in Client Components

Good to know:
  - Server Functions are designed for server-side mutations. The client currently dispatches and awaits them one at a time. This is an implementation detail and may change.
  - If you need parallel data fetching, use data fetching in Server Components, or perform parallel work inside a single Server Function or Route Handler.

  -> Forms
  - React extends the HTML <form> element to allow Server Function to be invoked with the HTML action prop.
  - When invoked in a form, the function automatically receives the FormData object. You can extract the data using the native FormData methods:

  Refer to - app/compontents/form.tsx & - app/action.tsx

  -> Event Handlers
  - You can invoke a Server Function in a Client Component by using event handlers such as onClick.

-> Examples
  -> Showing a Pending State

  - While executing a Server Function, you can show a loading indicator with React's useActionState hook. This hook returns a pending boolean:

  e.g:

  - app/component/buttons

  'use client'
 
  import { useActionState, startTransition } from 'react'
  import { createPost } from '@/app/actions'
  import { LoadingSpinner } from '@/app/ui/loading-spinner'
  
  export function Button() {
    const [state, action, pending] = useActionState(createPost, false)
  
    return (
      <button onClick={() => startTransition(action)}>
        {pending ? <LoadingSpinner /> : 'Create Post'}
      </button>
    )
  }

  -> Revalidating

  - After performing an update, you can revalidate the Next.js cache and show the updated data by calling revalidatePath or revalidateTag within the Server Function

  e.g; - app/lib/action.ts

  import { revalidatePath } from 'next/cache'
 
  export async function createPost(formData: FormData) {
    'use server'
    // Update data
    // ...
  
    revalidatePath('/posts')
  }

  -> Redirecting

  - You may want to redirect the user to a different page after performing an update. 
  - You can do this by calling redirect within the Server Function.

  e.g; - app/lib/actions.ts

  'use server'
 
  import { revalidatePath } from 'next/cache'
  import { redirect } from 'next/navigation'
  
  export async function createPost(formData: FormData) {
    // Update data
    // ...
  
    revalidatePath('/posts')
    redirect('/posts')
  }

  - Calling redirect throws a framework handled control-flow exception. Any code after it won't execute.
  - If you need fresh data, call revalidatePath or revalidateTag beforehand.

  -> Cookies

  - You can get, set, and delete cookies inside a Server Action using the cookies API:

  e.g; - app/actions.ts

  'use server'
 
  import { cookies } from 'next/headers'
  
  export async function exampleAction() {
    const cookieStore = await cookies()
  
    // Get cookie
    cookieStore.get('name')?.value
  
    // Set cookie
    cookieStore.set('name', 'Delba')
  
    // Delete cookie
    cookieStore.delete('name')
  }

  -> useEffects

  - You can use the React useEffect hook to invoke a Server Action when the component mounts or a dependency changes.
  - This is useful for mutations that depend on global events or need to be triggered automatically.
  - For example, onKeyDown for app shortcuts, an intersection observer hook for infinite scrolling, or when the component mounts to update a view count:

  e.g; - app/view-count.tsx

  'use client'
 
  import { incrementViews } from './actions'
  import { useState, useEffect, useTransition } from 'react'
  
  export default function ViewCount({ initialViews }: { initialViews: number }) {
    const [views, setViews] = useState(initialViews)
    const [isPending, startTransition] = useTransition()
  
    useEffect(() => {
      startTransition(async () => {
        const updatedViews = await incrementViews()
        setViews(updatedViews)
      })
    }, [])
  
    // You can use `isPending` to give users feedback
    return <p>Total Views: {views}</p>
  }
