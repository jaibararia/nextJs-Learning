=> Layouts and Pages

- Next.js uses file-system based routing, meaning you can use folders and files to define routes.
- This page will guide you through how to create layouts and pages, and link between them.

=> Creating a page
- A page is UI that is rendered on a specific route.
- To create a page, add a page file inside the app directory and default export a React component.
- For example, to create an index page (/):

Example:
- app
    - page.tsx

====== code =====
export default function Page(){
    return <h1>Hello World</h1>
}

=> Creating a layout
- A layout is UI that is shared between multiple pages.
- On navigation, layouts preserve state, remain interactive, and do not rerender.
- You can define a layout by default exporting a React component from a layout file.
- The component should accept a children prop which can be a page or another layout.

- For example, to create a layout that accepts your index page as child, add a layout file inside the app directory:

- app
    - layout.tsx
    - page.tsx

===== code =====
export default function RootLayout({
    children,
}: Readonly<{
    children : React.ReactNode;
}>){
    return (
        <html lang="en">
        <body>
            {/* Layout UI */}
            {/* Place children where you want to render a page or nested layout */}
            <main>{children}</main>
        </body>
        </html>
    )
}

- The layout above is called a root layout because it's defined at the root of the app directory.
- The root layout is required and must contain html and body tags.

=> Creating a nested route

A nested route is a route composed of multiple URL segments. For example, the /blog/[slug] route is composed of three segments:
- / (Root Segment)
- blog (Segment)
- [slug] (Leaf Segment)

In Next.js:

- Folders are used to define the route segments that map to URL segments.
- Files (like page and layout) are used to create UI that is shown for a segment.

- To create nested routes, you can nest folders inside each other.
- For example, to add a route for /blog, create a folder called blog in the app directory.
- Then, to make /blog publicly accessible, add a page.tsx file:

- app
    - layout.tsx
    - page.tsx
    - blog
        - page.tsx

=> Nesting layouts
- By default, layouts in the folder hierarchy are also nested, which means they wrap child layouts via their children prop.
- You can nest layouts by adding layout inside specific route segments (folders).
- For example, to create a layout for the /blog route, add a new layout file inside the blog folder.

- app
    - page.js
    - layout.js
    - blog
        - layout.js
        - page.js
        - [slug]
            - page.js

- app / blog / layout.tsx
export default function BlogLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <section>{children}</section>
}

- If you were to combine the two layouts above, the root layout (app/layout.js) would wrap the blog layout (app/blog/layout.js),
- which would wrap the blog (app/blog/page.js) and blog post page (app/blog/[slug]/page.js).

=> Creating a dynamic segment
- Dynamic segments allow you to create routes that are generated from data.
- For example, instead of manually creating a route for each individual blog post, you can create a dynamic segment to generate the routes based on blog post data.
- To create a dynamic segment, wrap the segment (folder) name in square brackets: [segmentName].
- For example, in the app/blog/[slug]/page.tsx route, the [slug] is the dynamic segment.

==== code ====
export default async function BlogPostPage({
  params,
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = await params
  const post = await getPost(slug)
 
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </div>
  )
}

- Nested layouts within Dynamic Segments, can also access the params props.

=> Creating a dynamic segment
Example


=> Rendering with search params

- In a Server Component page, you can access search parameters using the searchParams prop:

example:

export default async function Page({
  searchParams,
}: {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}) {
  const filters = (await searchParams).filters
}

- Using searchParams opts your page into dynamic rendering because it requires a incoming request to read the search parameters from.
- Client Components can read search params using the useSearchParams hook.

=> What to use and when
- Use the searchParams prop when you need search parameters to load data for the page (e.g. pagination, filtering from a database).
- Use useSearchParams when search parameters are used only on the client (e.g. filtering a list already loaded via props).
- As a small optimization, you can use new URLSearchParams(window.location.search) in callbacks or event handlers to read search params without triggering re-renders.

=> Linking between pages

- You can use the <Link> component to navigate between routes. <Link> is a built-in Next.js component that extends the HTML <a> tag to provide prefetching and client-side navigation.
- For example, to generate a list of blog posts, import <Link> from next/link and pass a href prop to the component:

Example:

import Link from 'next/link'
 
export default async function Post({ post }) {
  const posts = await getPosts()
 
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.slug}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}

- Good to know: <Link> is the primary way to navigate between routes in Next.js. You can also use the useRouter hook for more advanced navigation.
